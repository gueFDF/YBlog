# 一、操作系统结构

### 1、微内核和外核的主要区别是什么？他们的优势和劣势分别是什么？

- **微内核操作系统**

微内核将传统宏内核中的驱动程序甚至包括许多功能，比如文件系统、网络、GUI等都变成用户态的进程。而**内核中仅仅保存一些最重要的功能**：进程管理、内存管理进程间通信以及硬件抽象层。

![](https://github.com/yanyanran/pictures/blob/main/%E5%BE%AE%E5%86%85%E6%A0%B8.png?raw=true)

> 1. ***优势***
>
>    因为做了板块分离，所以在功能维护和升级的效率就会更高；同时系统也会更加稳定、安全、可定制化；并且因为微内核把各种服务和驱动都分离开来，这就允许让各种系统服务运行在不同的芯片或者电脑上，可以让很多太计算机来运行同一个操作系统。这对分布式计算和云计算提供了更多可能。
>
> 2. ***劣势***
>
>    性能问题。相比于把所有功能都打包一起的宏内核，微内核的内核态和用户态之间的频繁切换会很耗时。

- **外核**

外核的目标是让程序获得更多控制**硬件**的自由，让开发者对硬件的控制更深。外核操作系统减少“操作系统必须提供构建程序的抽象内容”的传统概念。外核实现了应用级资源管理，即“**由应用程序而不是操作系统管理硬件资源**”。

![](https://github.com/yanyanran/pictures/blob/main/%E5%A4%96%E6%A0%B8.png?raw=true)

------

------

# 二、内存管理

### 1、关于物理内存和虚拟内存？

在虚拟内存出现之前，程序寻址用的都是物理地址。但物理地址是有限的，所以有了虚拟内存的存在。

出现虚拟地址后的程序执行时，***CPU会把虚拟地址转化为实际的物理地址，然后通过物理地址访问物理内存***。

- **内存管理单元MMU：地址翻译**

  由此引出内存管理单元的概念，它负责虚拟地址到物理地址之间的转换。

- **TLB：加速地址翻译的重要硬件**

  为了减少地址翻译的访存次数，MMU引入了***转址旁路缓存***--TLB。

  TLB缓存了**虚拟页号和物理页号**之间的映射关系，可以类拟为一个**kv哈希表**。

  > #### 虚拟内存里有一个很重要的结构：***页表***
  >
  > 页表是内存管理系统中的数据结构，用于向每个进程提供一致的虚拟地址空间，**每个页表项保存的是虚拟地址到物理地址的映射以及一些管理标志**。 
  >
  > 应用进程只能访问虚拟地址，内核必须***借助页表和硬件把虚拟地址翻译为对物理地址的访问***。

### 2、虚拟内存的功能

- #### **内存共享**

  内存共享允许同一个物理页中的不同程序共享一块内存。如下图所示，程序A和B的虚拟页都被映射到了同一个块内存上，这意味着程序A和B读取对应的内存页所显示的结果是一样的，同时也代表着相互之间可以看到对方修改的内容。

![](https://github.com/yanyanran/pictures/blob/main/%E5%86%85%E5%AD%98%E5%85%B1%E4%BA%AB.png?raw=true)

- #### **写时拷贝**

  copy on write，即隐式共享。原理是将复制操作推迟到第一次写入操作时进行，创建一个新副本时不是复制资源，而是共享原始副本（复制页表）；只有修改的时候才会执行复制操作。

  > 比如当我们使用fork创建子进程的时候，操作系统需要将父进程虚拟内存空间里的大部分内容全部复制到子进程中 --> 耗时且浪费大量物理内存。
  >
  > 这时候使用写时拷贝技术后，内核不会复制进程的整个地址空间而只是复制页表，fork之后的父子进程的地址空间指向同样的；物理内存页。

  写时拷贝能节约物理内存资源，还可以让父子进程以只读的方式共享全部内存数据，避免内存拷贝操作带来的时间和空间开销。

  ​                    ![](https://imageslr.com/media/16050133758633.jpg)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         

- #### **内存去重**

  KSM，由操作系统自发开始。操作系统定期检查扫描具有相同内容的物理页，找到映射物理页的虚拟页，只保留一个物理页，然后释放其他的物理页。

  > 不过KSM会对程序访存延时造成影响。这儿有一个安全隐患，就是会有不法分子通过穷举法，不断构造数据然后等待系统去重，再通过时延确认是否发生了去重从而猜数据。

- #### **内存压缩**

  就是当内存不够的时候，系统会选择部分不常用的内存页，压缩其中的数据从而达到腾出内存的效果。再访问的时候解压即可。

- #### 大页

  前面说到过TLB --> 加速地址翻译的部件。因为**翻译每个内存页都需要占用一个TLB缓存项**，而CPU中的TLB又是有限的，所以当程序数量变大时就会出现TLB不够用的情况。这时候大页来了，使用大页有以下好处：

  > 1. **减少TLB缓存项的使用，从而提高TLB命中率；**
  > 2. **减少页表级数，提升查询页表的效率。**

过度使用大页也有缺点：程序没有完全使用完整个大页从而造成资源浪费；大页的使用也会增加操作系统的管理内存的复杂度。

------

------

# 三、进程与线程

### 1、进程

- #### 进程控制块：PCB

  内核中每个进程都通过一个数据结构来**保存它的状态**，这个数据结构就叫PCB。

  PCB中包括进程标识符（PID）、进程状态、虚拟内存状态等等信息。

  

> 关于寄存器、CPU和内存的关系：https://blog.csdn.net/qq_39759656/article/details/82081974#commentBox

- #### 创建进程：fork() --- “调用一次，返回两次”

  fork不接受任何参数。

  1. 对于父进程，fork返回子进程的PID
  2. 对于子进程，fork返回0

  fork刚完成时父子进程的**内存、寄存器都完全一样**，但他俩是完全独立的两个进程。他俩**PID和虚拟内存空间都是完全不同的**，互不打扰。

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char *argv) {
    int x = 42;
    int rc = fork();
    if(rc < 0) {
        fprintf(stderr, "Fork failed\n");
    } else if(rc == 0) {
        // 子进程
        printf("Child process rc is %d; The value of x is %d\n",rc, x);
    } else {
        // 父进程
        printf("Parent process rc is %d; The value of x is %d\n", rc, x);
    }
}
/*
Parent process rc is 75758; The value of x is 42
Child process rc is 0; The value of x is 42
*/
```

当我们对文件操作时：

```C
int file() {
    str[10] = 0;
    int fd = open("test.txt", O_RDWR);
    if(fork() == 0) {
        ssize_t cnt = read(fd, str, 10);
        printf("Child process:%s\n", (char *)str);
    } else {
        ssize_t cnt = read(fd, str, 10);
        printf("Parent process:%s\n", (char *)str);
    }
    return 0;
}
/*
两个输出字符不一样
*/
```

会发现父进程和子进程的输出文件内容不一样！这是咋回事，前面不说了是“完全一样的拷贝”吗？问题的关键就在于“拷贝”上。