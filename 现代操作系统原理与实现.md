# 一、操作系统结构

### 1、微内核和外核的主要区别是什么？他们的优势和劣势分别是什么？

- ##### **微内核操作系统**

微内核将传统宏内核中的驱动程序甚至包括许多功能，比如文件系统、网络、GUI等都变成用户态的进程。而**内核中仅仅保存一些最重要的功能**：进程管理、内存管理进程间通信以及硬件抽象层。

![](https://github.com/yanyanran/pictures/blob/main/%E5%BE%AE%E5%86%85%E6%A0%B8.png?raw=true)

> 1. ***优势***
>
>    因为做了板块分离，所以在功能维护和升级的效率就会更高；同时系统也会更加稳定、安全、可定制化；并且因为微内核把各种服务和驱动都分离开来，这就允许让各种系统服务运行在不同的芯片或者电脑上，可以让很多太计算机来运行同一个操作系统。这对分布式计算和云计算提供了更多可能。
>
> 2. ***劣势***
>
>    性能问题。相比于把所有功能都打包一起的宏内核，微内核的内核态和用户态之间的频繁切换会很耗时。

- ##### **外核**

外核的目标是让程序获得更多控制**硬件**的自由，让开发者对硬件的控制更深。外核操作系统减少“操作系统必须提供构建程序的抽象内容”的传统概念。外核实现了应用级资源管理，即“**由应用程序而不是操作系统管理硬件资源**”。

![](https://github.com/yanyanran/pictures/blob/main/%E5%A4%96%E6%A0%B8.png?raw=true)

------

------

# 二、内存管理

### 1、关于物理内存和虚拟内存？

在虚拟内存出现之前，程序寻址用的都是物理地址。但物理地址是有限的，所以有了虚拟内存的存在。

出现虚拟地址后的程序执行时，***CPU会把虚拟地址转化为实际的物理地址，然后通过物理地址访问物理内存***。

- ##### **内存管理单元MMU：地址翻译**

  由此引出内存管理单元的概念，它负责虚拟地址到物理地址之间的转换。

- ##### **TLB：加速地址翻译的重要硬件**

  为了减少地址翻译的访存次数，MMU引入了***转址旁路缓存***--TLB。

  TLB缓存了**虚拟页号和物理页号**之间的映射关系，可以类拟为一个**kv哈希表**。

  > #### 虚拟内存里有一个很重要的结构：***页表***
  >
  > 页表是内存管理系统中的数据结构，用于向每个进程提供一致的虚拟地址空间，**每个页表项保存的是虚拟地址到物理地址的映射以及一些管理标志**。 
  >
  > 应用进程只能访问虚拟地址，内核必须***借助页表和硬件把虚拟地址翻译为对物理地址的访问***。

### 2、虚拟内存的功能

- #### **内存共享**

  内存共享允许同一个物理页中的不同程序共享一块内存。如下图所示，程序A和B的虚拟页都被映射到了同一个块内存上，这意味着程序A和B读取对应的内存页所显示的结果是一样的，同时也代表着相互之间可以看到对方修改的内容。

![](https://github.com/yanyanran/pictures/blob/main/%E5%86%85%E5%AD%98%E5%85%B1%E4%BA%AB.png?raw=true)

- #### **写时拷贝**

  copy on write，即隐式共享。原理是将复制操作推迟到第一次写入操作时进行，创建一个新副本时不是复制资源，而是共享原始副本（复制页表）；只有修改的时候才会执行复制操作。

  > 比如当我们使用fork创建子进程的时候，操作系统需要将父进程虚拟内存空间里的大部分内容全部复制到子进程中 --> 耗时且浪费大量物理内存。
  >
  > 这时候使用写时拷贝技术后，内核不会复制进程的整个地址空间而只是复制页表，fork之后的父子进程的地址空间指向同样的；物理内存页。

  写时拷贝能节约物理内存资源，还可以让父子进程以只读的方式共享全部内存数据，避免内存拷贝操作带来的时间和空间开销。

  ​                    ![](https://imageslr.com/media/16050133758633.jpg)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         

- #### **内存去重**

  KSM，由操作系统自发开始。操作系统定期检查扫描具有相同内容的物理页，找到映射物理页的虚拟页，只保留一个物理页，然后释放其他的物理页。

  > 不过KSM会对程序访存延时造成影响。这儿有一个安全隐患，就是会有不法分子通过穷举法，不断构造数据然后等待系统去重，再通过时延确认是否发生了去重从而猜数据。

- #### **内存压缩**

  就是当内存不够的时候，系统会选择部分不常用的内存页，压缩其中的数据从而达到腾出内存的效果。再访问的时候解压即可。

- #### 大页

  前面说到过TLB --> 加速地址翻译的部件。因为**翻译每个内存页都需要占用一个TLB缓存项**，而CPU中的TLB又是有限的，所以当程序数量变大时就会出现TLB不够用的情况。这时候大页来了，使用大页有以下好处：

  > 1. **减少TLB缓存项的使用，从而提高TLB命中率；**
  > 2. **减少页表级数，提升查询页表的效率。**

过度使用大页也有缺点：程序没有完全使用完整个大页从而造成资源浪费；大页的使用也会增加操作系统的管理内存的复杂度。

------

------

# 三、进程与线程

### 1、进程

- #### 进程控制块：PCB

  内核中每个进程都通过一个数据结构来**保存它的状态**，这个数据结构就叫PCB。

  PCB中包括进程标识符（PID）、进程状态、虚拟内存状态等等信息。

  

> 关于寄存器、CPU和内存的关系：https://blog.csdn.net/qq_39759656/article/details/82081974#commentBox

- #### 创建进程：fork() --- “调用一次，返回两次”

  fork不接受任何参数。

  1. 对于父进程，fork返回子进程的PID
  2. 对于子进程，fork返回0

  fork刚完成时父子进程的**内存、寄存器都完全一样**，但他俩是完全独立的两个进程。他俩**PID和虚拟内存空间都是完全不同的**，互不打扰。

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char *argv) {
    int x = 42;
    int rc = fork();
    if(rc < 0) {
        fprintf(stderr, "Fork failed\n");
    } else if(rc == 0) {
        // 子进程
        printf("Child process rc is %d; The value of x is %d\n",rc, x);
    } else {
        // 父进程
        printf("Parent process rc is %d; The value of x is %d\n", rc, x);
    }
}
/*
Parent process rc is 75758; The value of x is 42
Child process rc is 0; The value of x is 42
*/
```

当我们对文件操作时：

```C
int file() {
    str[10] = 0;
    int fd = open("test.txt", O_RDWR);	// 先open再fork
    if(fork() == 0) {
        ssize_t cnt = read(fd, str, 10);
        printf("Child process:%s\n", (char *)str);
    } else {
        ssize_t cnt = read(fd, str, 10);
        printf("Parent process:%s\n", (char *)str);
    }
    return 0;
}
/*
两个输出字符不一样
*/
```

**会发现父进程和子进程的输出文件内容不一样！**这是咋回事，前面不说了是“完全一样的拷贝”吗？问题的关键就在于“拷贝”上。

> 每个进程在运行过程中都会维护一张已打开的文件描述符表（**fd表**），它是操作系统提供的对文件引用的抽象。
>
> fd会使用**偏移量**记录当前进程对文件读取的位置。
>
> 之所以使用文件描述符而非直接指向文件系统中的某个文件，是因为文件结构可能会因为文件系统的不同而发生改变，所以将其单一抽象出来有利于操作系统管理。

上面的例子是先open再fork的。在fork过程中，父子进程会获得**一模一样的fd表**。因此**会指向相同的文件抽象，偏移量也是共用的。**而Linux在实现read操作的时候会对文件抽象加锁，所以读到的字符串肯定不一样：

![](https://img-blog.csdnimg.cn/20190518090331280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpbmdPZk15SGVhcnQ=,size_16,color_FFFFFF,t_70)

如果想要让父子进程独立开，读取到相同的字符串，只需要将模式改为**先fork再open**即可。

![](https://img-blog.csdnimg.cn/20190518091138732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpbmdPZk15SGVhcnQ=,size_16,color_FFFFFF,t_70)

- #### 3执行进程：exec接口

  创建父子进程后，我们通常希望子进程去执行其他的命令，这时候就会用到exec接口。此接口目前最全面的方法是execve：

  ```c
  int execve(const char *patname, char *const argv[], char *const encp[]);
  // pathname：进程需载入的可执行文件的路径
  // argv：进程执行参数
  // envp：为进程定义的环境变量（键值对字符串形式传入）
  ```

  调用execve时，操作系统至少经历以下步骤：

  1. 根据pathname将可执行文件的数据段和代码段载入当前进程的地址空间中；

  2. 重新初始化堆和栈；

  3. 将PC寄存器设置到可执行文件代码段定义的入口点，该入口点最终会调用main

     > #### **PC寄存器：程序计数器**
     >
     > 用于**存放下一条指令所在单元的地址**。
     >
     > 当执行一条命令时，首先根据PC中存放的指令地址，将指令由内存取到指令寄存器中，也就是我们所说的“***取指令***”的过程。

- #### 进程关系

  进程间的关系可以用**树**的结构来描述，每个进程的task_struct都会记录自己的父进程和子进程。

  > 1. **进程组**：进程的集合
  > 2. **会话**：进程组的集合

- #### 进程监控：wait接口

  和exec结构相似，wait操作主要使用waitpid来监控：

  ```c
  int waitpid(pid_t pid, int *wstatus, int options);
  // pid：需要等待的子进程id
  // wstatus：保存子进程状态
  // options：包含一些选项
  ```

  具体使用如下：

  ```C
  #include <stdio.h>
  #include <stdlib.h>
  #include <sys/types.h>
  #include <sys/wait.h>
  #include <unistd.h>
  
  int main(int argc,  char *argv[]) {
      int rc = fork();
      if(rc < 0) {
          // fork失败
          fprintf(stderr, "Fork faoled\n");
      }else if(rc == 0) {
          // 子进程
          printf("Child process: exiting.\n");
      } else {
          // 父进程
          int status = 0;
          if(waitpid(rc, &status, 0) < 0) {
              // waitpid失败
              fprintf(stderr, "Waitpid failed\n");
              exit(-1);
          }
          if(WIFEXITED(status)) { // 判断子进程是否退出
              printf("Parents process: my child has exited\n");
          }else {
              fprintf(stderr, "Parent process :waitpid returns for unkown reason\n");
          }
      }
  }
  /*
  Child process: exiting.
  Parents process: my child has exited
  */
  ```

  上面这个例子中，父进程调用waitpid对子进程进行监控。**如果子进程退出，则witpid会立刻返回并设置status变量的值；如果子进程没有退出，那么waitpid会阻塞并等待子进程退出。**同时父进程可以通过访问statu值来查看子进程状态。

> ### 僵尸进程
>
> wait操作不仅起到监控作用，同时还会回收结束的子进程和释放资源。
>
> 如果父进程没有调用wait的话，结束的子进程的pid和终止信息将会一直保留，这将会占用内存。**如果一个父进程一直fork子进程而不wait的话，子进程的pid将会不断占取大量的内存空间，最终使得内核资源不够而无法fork。**

- #### 创建和执行合二为一：posix_spawn

前面说到的fork存在一些缺点：比如说每当操作系统为进程结构添加功能时都要考虑对fork的修改；再者就是fork性能太差，拷贝时间遇到大内存时耗时过长.....

posix_spawn是fork+exec的结合：

```c
int posix_spawn(pid_t *pid, 
                const char *path,
                const posix_spawn_file_actions_t *file_actions, 
                const posix_spawnattr_t *attrp, 
                char *const argv[], 
                char *const envp[]);
// pid：在spawn返回时被写入新进程的PID
// path：进程需载入的可执行文件的路径
// file_actions：（）
// attrp：（）
// argv：进程执行参数
// envp：为进程定义的环境变量（键值对字符串形式传入）
```

posix_spawn调用过程中，在exec过程执行前会根据file_actions和attrp两个参数的配置完成一系列操作。

**相比于fork+exec的组合，spawn的性能要优先于组合；但由于参数的原因，灵活度没有组合高。**

- #### 特定条件下的fork改良：vfork()

  ```C
  pid_t vfork(void);
  ```

  **在进程创建后立即使用exec**，由于exec本身会创建地址空间，因此vfork与fork相比**省去了一次地**
  **址空间的拷贝**。

- #### 紧密控制：clone

  如果程序希望选择性共享父子进程的部分资源，这时候fork就不管用了。Linux根据rfork接口提出了类似的clone接口，支持程序通过参数对创建过程进行更多控制。

------

### 2、线程

早期计算机的最小运行程序单位是进程。但随着计算机硬件水平的提高，计算机拥有更多CPU核心，以线程为最小单位就显得有些笨重：

1. 

> 1. 首先，**创建线程的开销较大**。即使是使用fork创建进程，也需要对父进程的状态进行大量拷贝；
> 2. 进程间的虚拟内存空间是独立的，所以在**进程间共享数据相对而言比较麻烦**（共享虚拟内存页粒度太大、进程间通信开销太大）

所以有了线程中的一个个独立执行单元：线程。**线程之间共享进程地址空间，但又各自保存运行时所需的状态。**

#### *多线程地址空间布局：内核栈与用户栈是分离的状态，除栈以外其余区域均为共享状态。*

- #### 用户态线程和内核态线程

  内核态线程由内核创建，受操作系统调度器直接调用；而用户态线程是应用自己创建的，内核不可见自然也就不受操作系统调度。

  为了**实现内核态线程与用户态线程的协作**，操作系统建立了两类线程之间的关系称之为**多线程模型**。

- #### 线程控制块TCB

  前面介绍过进程的控制块PCB。和PCB类似，内核态TCB中主要存储的是线程的运行状态、内存映射、标识符等等信息；而用户态TCB结构主要靠线程库决定。

  我们可以**把用户态TCB看作是内核态TCB的扩展 -- 它可以用来存储更多与用户态相关的信息**。其中有一个很重要的功能是TLS：线程本地存储

  > #### 线程本地存储：TLS
  >
  > 我们知道一个进程中的全局变量和静态static变量是归所有线程共享的。在一个线程中修改这个变量将会对所有的线程都生效。
  >
  > 这是个好事，但不完全是。好在于所有的线程之间改变变量会变得非常嗯块，缺点就是如果一个线程死掉了，其他线程页将会不保。
  >
  > 这时我们可以使用TLS机制**为每一个使用该全局变量的线程都提供一个变量值的副本，每一个线程都可以任意更改自己的副本而不会与其他线程副本冲突。**

- #### 线程接口

  |  **创建线程**  |  p**thread_create**   |
  | :------------: | :-------------------: |
  |  **线程退出**  |   **pthread_exit**    |
  |  **出让资源**  |   **pthread_yield**   |
  |  **线程合并**  |   **pthread_join**    |
  | **挂起和唤醒** | **pthread_cond_wait** |

  不过和进程不一样，**线程退出exit的调用不是必要的**。当一个线程的主函数执行结束的时候pthread_exit会被隐式调用。

------

### 3、纤程

纤程是一种轻量化的线程（用户态线程）。因为用户态线程更加轻量级，要比内核态线程的创建和切换的开销要小很多，可以增加系统的可扩展性。